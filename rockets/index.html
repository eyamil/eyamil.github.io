<html>
    <head>
        <title>Rockets</title>
        <meta name = "viewport" content = "user-scalable=no, initial-scale=1.0, maximum-scale=1.0, width=device-width">
        <link rel='stylesheet' href='../index.css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Advent+Pro' rel='stylesheet' type='text/css'>
        <script type='text/javascript' src='../index.js'></script>
        <script type='text/javascript' src='../vectors.js'></script>
        <script type='text/javascript' src='../paper-full.js'></script>
        <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <style type='text/css'>
            #c {
                height:100%;
                width:100%;
            }
            #banneroverlay {
                box-shadow:inset 0px 0px 150px rgba(255,255,255,0.1);
            }
            
            #bannerbkg {
                z-index:1;
            }
            
            #banner {
                background-color:black;
            }
            
            #vexSub {
                background-color:rgba(0,0,0,0.1);
                margin-left:auto;
                margin-right:auto;
                height:500px;
                width:500px;
            }
        </style>
    </head>
    <body>
        <div id='banner'>
            <div id='banneroverlay'></div>
            <div id='bannertext'>
                <h1>Rockets</h1>
                <input id='slider'>
                <h5>A mini-project on acceleration</h5>
            </div>
            <div id='bannerbkg' style='width:100%;'>
                <canvas id='c' resize='true' />
                <script type='text/javascript'>
                    var dt = 0.01; 
                        // The time step, in seconds. Used to approximate in integration. Smaller is better, but also may cause performance issues.
                    var innerScR = 0.25;
                    var x = [(window.innerWidth/2 + window.innerWidth*innerScR), (window.innerHeight/2)];
                    var v = [0, 200];
                    var absV = vmag(v);
                        // Set up initial position and velocity as vectors.
                    var slider = document.getElementById('slider');
                        slider.type = 'range';
                        slider.class = 'slider';
                        slider.max = 0.125*Math.pow(vmag(v),2);
                        slider.min = -1*slider.max;
                        slider.class = 'center';
                        slider.value = (Math.pow(200,2))/(window.innerWidth*innerScR);
                        function Amag() {
                            return(slider.value);
                        }
                      // Set up the slider for acceleration.
                    var O = document.getElementById('marker');
                        // Set up a marker element to see where this thing goes.
                    function a() {
                        var rot90 = [[0,1],[-1,0]]; // 90 degree clockwise rotation matrix.
                        if (vmag(v) != 0) {
                            var vmat = [norm(v)]; // Unit vector in the direction of the velocity.
                        }
                        else {
                            var vmat = [[0,0]]
                        }
                        return(vscale(Amag(),(mmult(vmat,rot90)[0]))); // Rotate normalized V by 90 deg (because centripetal acc is always perpendicular), then scale.
                    }
                        // Function that returns centripetal acceleration vector.
                    function updatev() {
                        // Just scaling by dt is slightly inaccurate. As you repeat it over time, you'll see the magnitude of v start to increase, so instead, we need some additional scaling to preserve |v|. First we normalize the vsum to preserve its direction, then we scale up to absV, the magnitude of the velocity at time t=0.
                        v = vscale(absV, norm(vsum(v,vscale(dt,a()))));
                        return(v);
                    }
                        // Function that updates velocity. v_{t} = v_{t-1} + (a)*(Δt)
                    function updatex() {
                        x = vsum(x,vscale(dt,v),vscale((0.5*Math.pow(dt,2)),a()));
                        return(x);
                    }
                        // Function that updates velocity. x_{t} = x_{t-1} + (v_{t-1})*(Δt) + (1/2)*(a_t)*(Δt)^2 <-- that will always return 2, use Math.pow() instead of ^.
                    function update() {
                        /* We can eventually get rid of this. It'll allow us to de-link the animation clock from the integration clock.
                        O.style.left = mod(x[0] + window.innerWidth/2, window.innerWidth);
                        O.style.top = mod(x[1] + window.innerHeight/2, window.innerHeight);
                        */
                        // Calculation steps:
                        updatex();
                        updatev();
                        // Drawing steps:
                        drawship();
                        drawradius(); // Commented out temporarily for debugging. I'm going to draw the spaceship first.
                        paper.view.draw();
                    }
                    var integrator = setInterval(update,(1000*dt));
                    
                    // We need a souped up angle function that doesn't jump in order to get the spaceship to draw properly.
                    function vangle(v1,v2) {
                        var n1 = norm(v1);
                        var n2 = norm(v2);
                        var rawcosangle = Math.acos(dotprod(n1,n2));
                        var D = det([n1,n2]);
                        if (D < 0) {
                            return(-1*rawcosangle)
                        }
                        else {
                            return(rawcosangle);
                        }
                    }
                    
                    function mod(n, m) { // An improved mod function, lets us avoid negative numbers in the result
                        return(((n % m) + m) % m);
                    }
                    
                    function convertto() { // Meant to convert from integration units to pixels, including the shift to the center of the window.
                        // Eventually there will be stuff here
                    }
                    
                    /* Paper/Drawing stuff starts here: */
                    var canvas = document.getElementById('c');
                        paper.setup(canvas);
                        
                    var Rpath = new paper.Path();
                        Rpath.strokeColor = 'grey';
                        // Start a radius path in gray
                    function drawradius() {
                        Rpath.clear(); // Clear the earlier radius path
                        var acc = a(); // Create a storage variable
                        if (vmag(acc) !== 0) { // As long as the acceleration isn't a zero vector, we can proceed
                            var absR = (Math.pow(absV,2))/(vmag(acc)); // Find the magnitude of the radius and store it to absV
                            var r = vscale((absR),norm(acc)); // Take the acceleration vector and 
                            var start = new paper.Point(x);
                            Rpath.moveTo(start);
                            Rpath.lineTo(vsum(r,x));
                            return(r);
                        }
                    }
                
                    var Spath = new paper.Path();
                        Spath.strokeColor = 'blue';
                        Spath.fillColor = 'white';
                        // Draw the Ship in blue
                    function drawship() {
                        Spath.clear();
                        var Urwing = [-10, -20];
                        var Ulwing = [10, -20];
                            // Set up the ship's triangle shape in unrotated space.
                        var dir = vangle(v, [0,1]); // Find the angle between a unit vector to the right and the velocity
                        var rotMat = [[Math.cos(dir), -Math.sin(dir)], [Math.sin(dir), Math.cos(dir)]]; // Set up a rotation matrix to rotate the shape we had before.
                        var UTRwing = mmult([Urwing], rotMat)[0]; // Rotate the Urwing vector to get the coordinates of the untranslated right wing
                        var UTLwing = mmult([Ulwing], rotMat)[0]; // ^ for the left wing. The tip doesn't get rotated, oh well.
                        var tip = new paper.Point(x);
                            Spath.moveTo(tip);
                            Spath.lineTo(vsum(x,UTRwing));
                            Spath.lineTo(vsum(x,UTLwing));
                            Spath.lineTo(tip);
                        }
                    </script>
                </div>
        </div>
        <div id='content'>
            <article id='post'>
                <h1>Centripetal Acceleration</h1>
                <p>
                    Centripetal acceleration is the phenomenon that describes anything physical that travels in circles. Here's its derivation: 
                    $$\mathrm{1.}\;\vec{r}\cdot\vec{r}=|\vec{r}|^2$$
                    $$\mathrm{2.}\;\frac{d}{dt}\left(\vec{r}\cdot\vec{r}\right)=\frac{d}{dt}\left(|\vec{r}|^2\right)$$
                    $$\mathrm{3.}\;\frac{d\vec{r}}{dt}\cdot\vec{r}+\frac{d\vec{r}}{dt}\cdot\vec{r}=0$$
                    $$\mathrm{4.}\;\frac{d\vec{r}}{dt}\cdot\vec{r}=0$$
                    $$\mathrm{5.}\;\vec{v}\cdot\vec{r}=0$$
                    $$\mathrm{6.}\;\frac{d}{dt}\left(\vec{v}\cdot\vec{r}\right)=\frac{d}{dt}0$$
                    $$\mathrm{7.}\;\frac{d\vec{v}}{dt}\cdot\vec{r}+\frac{d\vec{r}}{dt}\cdot\vec{v}=0$$
                    $$\mathrm{8.}\;\vec{a}\cdot\vec{r}+\vec{v}\cdot\vec{v}=0$$
                    $$\mathrm{9.}\;\vec{v}\cdot\vec{v}=-\vec{a}\cdot\vec{r}$$
                    Without any context or explanation, this probably just looks like a meaningless string of symbols. But let's bring in that context. 
                    </br>
                    </br>
                    First off, any time I bring up a symbol with an arrow (Like this: \(\vec{v}\) ), that's a vector. Basically it's just a handy tool for describing quantities that have more than one dimension. For example, in general, it's not possible to describe motion in our world with just one dimension, because lots of things don't move on lines. When I use these symbols: \( || \) around a vector, I just mean its magnitude, or size. The dot product, \( \cdot \), represents the parallel projection of a vector onto another direction. It answers the question, "How much of vector \( \vec{x} \) is in the same direction as \( \vec{y} \)?". Finally, the symbol \( \frac{d}{dt} \) represents differentiation. Basically, it tells you how much a quantity is changing instantaneously.
                    Now, let's get to the meat of the demonstration: the derivation.
                    </br>
                    </br>
                    The first step we're starting off with is an assumption we've made. Given that \( |\vec{r}| \) stays constant, this step is actually true by definition. Basically what we're saying is that the radial vector's length is going to stay constant, which makes sense, because a circle is defined by the property that the radius is constant.
                    </br>
                    </br>
                    Next, what we've done is differentiated both sides. On the right hand side of the equation, we know that \( |\vec{r}| \) is constant. As a result, we can find out that \( |\vec{r}|^2 \) has to be constant. Since a constant quantity can't change over time, its derivative has to be zero, which explains the right hand sides of steps 2 and 3. On the left hand sides, all that's going on is an application of the <a href='https://en.wikipedia.org/wiki/Product_rule'>Product Rule</a>.
                    </br>
                    </br>
                    Between steps 3 and 4, all we've done is some algebra to bring this expression down to something less messy. Then, in step 5, what's going on is an application of a cool substitution. Turns up, \( \frac{d\vec{r}}{dt} \) is just \( \vec{v} \). Here's a visual explanation of why:
                    <canvas id='vexSub' resize='true' />
                    </br>
                    <script type='text/javascript'>
                        var DemoX = [];
                        var DemoV = [];
                        
                    </script>
                    Whenever the dot product of two vectors with magnitude is 0, that implies that the two vectors are perpendiular to each other. Basically, all we have is a derivation that if the radius is constant, at any point in time, the velocity vector has to be perpendicular to the radial vector.
                </p>
                <h1>Making the Demo</h1>
                <p>
                    Stuff here, eventually 
                    </br>
                    </br>
                </p>
            </article>
        </div>
    </body>
</html>
